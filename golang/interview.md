### 值类型&引用类型传递

引用类型传递: `map`, `slice`, `interface`, `chan`, `pointer` 

值类型传递: `array`, `struct` ,`int`, `float`, `bool`, `string`

*make可以创建哪些*

```go
	var ch, sl, ma = make(chan int), make([]int, 0), make(map[int]int)
```

* make, new 的区别

1. make 只能创建三种类型，new 可以创建任意类型
2. make返回的是Type对象，new 返回的是Type指针

### 控制并发控制的三种模式

1. 通过`chan`进行控制
1. 通过`Waitgroup`进行控制
1. 通过`Context`上下文进行控制


### gRPC

gRPC是RPC框架的一种实现，RPC是一种远程服务调用，RPC负责底层的通信协议和序列化方式。服务调用者可以想调用本地函数一样调用远程服务。
gRPC对接口与严格的约束，安全性高，且更适合高并发场景。
gRPC有明确的接口规范，
RCP效率更高，RPC使用自定义的TCP协议，可以让请求报文体积更小，提高传输效率


rest，是网络中的clinet和server的交互形式

### 读写锁

golang的`sync`包提供了 互斥锁`sync.Mutex`和读写锁`sync.RWMutex`两种锁

`sync.Mutex`互斥锁，既不可同时运行。互斥锁有两个方法`Lock`和`Unlock`。通常在加锁有采用`defer`语句解锁。

`sync.RWMutex`读写锁，可以理解为`多读单写锁`。`读`是运行同时运行的，`写`是互斥的。一般有四种情况

读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。
写锁之间是互斥的，存在写锁，其他写锁阻塞。
写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。


### 协程和线程和进程的区别

* 进程

进程是系统资源分配和调度的最小单位，每个进程有自己的内存空间，不同进程之前通讯是通过进程通讯来完成

* 线程

线程是进程的一个实体，他是比进程更小的能独立运行的基本单位。线程间通讯最要通过共享内存，资源开销较小

* 协程

协程是一种用户态的轻量级线程，协程的调度是通过用户来进行控制的。协程拥有自己的寄存器上下文和栈（P）


线程是进程的一个实体

### GMP

* G: goroutine 调度实体, 既用户代码,   # 在本地队列中不断切换执行
* M: machine 内核线程, 既系统线程, 负责代码执行
* P: processor 逻辑处理器, 保存了调度上下文。也可以理解为局部的一个调度器。P的数量由`runtime.GOMAXPROCS`控制, 

每个p都有一个runqueue队列。p负责goroutine调度到`M线程`上运行。

除此之外呢，golang还维护一个全局的runqueue队列。


当某个p的本地runqueue队列运行完。首先 `p`就会从全局队列当中获取新的`goroutine`.

如果全局队列没有`goroutine`.

那么会从其它的`P`本地队列中偷一些`goroutine`(一半)


当某一个进程`M0`被阻塞时，P会找到一个新的`M1`进程上进行运行。
当被阻塞的`M0`返回`syscall`(既可以运行不阻塞了) `M0`会尝试获取一个`P`来继续运行。如果没有获取`P`，那么会将`MO`阻塞的`G`放入全局`runqueue`

### csp

CSP 模型是*以通信的方式来共享内存*，不同于传统的多线程通过共享内存来通信。

主要用于描述两个独立的并发实体, 通过共享的通讯 channel (管道)进行通信的并发模型。


### 如何退出`goroutine`

`goroutine`的退出一般有两种模式： 1.超时模式 2.关闭chan

超时模式是使用`time.After`启动了一个异步的定时器，返回一个 channel，当超过指定的时间后，该 channel 将会接受到信号

2，通过一个chan的关闭通知，进行`goroutine`的关闭 

### 什么情况下死锁，如何避免？

单个`goroutine`自读自写一个没有缓冲能力的`chan`

range `chan`时要注意关闭，如果不关闭一直阻塞


## 垃圾回收

#### 垃圾回收的三种算法

1. 引用计数

	每个对象维护一个引用计数, 当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。 [redis内存回收](https://iscod.github.io/#/nosql/redis?id=%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6)

	 redis就是采用的该种方法
2. 标记清除, 从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收
3. 分代收集

golang的垃圾回收是通过`GC`来实现的。

GC采用的理念是`三色标记`. `三色标记`可以理解成将一个内存标记为三种状态

1，白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收
2，黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象 以及从根对象可达的对象
3，灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象

垃圾回收的可以理解为三个步骤

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到不存在灰色对象；

当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾

### 反射

反射是通过`reflect`(ruifulekede)包来实现。它可以让程序操作不同类型的对象
`reflect`包提供了两个重要的接口`reflect.TypeOf` 和 `reflect.ValueOf`。TypeOf用来获取类型信息。ValueOf用来获取数据

 实现了运行时的反射能力，能够让程序操作不同类型的对象1。反射包中有两对非常重要的函数和类型，reflect.TypeOf 能获取类型信息，reflect.ValueOf 能获取数据的运行时表示

```
 type User struct {
	Name string
	Age  int
}

func main() {
	u := User{Name: "ning", Age: 12}
	tp := reflect.TypeOf(u)
	va := reflect.ValueOf(u)
	for i := 0; i < tp.NumField(); i++ {
		fmt.Println(tp.Field(i).Name, "：", va.FieldByName(tp.Field(i).Name))
	}
}

```


### 高并发场景

高并发是一个系统工程主要是通过四个方面来着优化

1. 业务层面
	1. 可以通过流程设计减少热点数据的访问量，比如做预约,增加实名认证等条件才可参加活动
	1. 比如可以增加访问验证码等步骤，延迟用户核心数据访问频率，同时可以放置抢购脚本

1. 服务器硬件设施方面
	1. 系统分离，可以尝试将高并发场景单独做成一个server服务，单独部署减少对其他系统的影响。并且可以专门做相应的优化，比如请求较高可以做动态的伸缩服务器硬件。也可以进行相应的流量均衡
	1. 可以做一些静态资源的缓存CDN。减少对核心服务器的访问。

1. 代码逻辑层面
	1. 尽可能的减少数据操作（读写数据库）。
	1. 可以采用消息队列做中间层，将并发的访问转换为顺序的请求访问
	1. golang的本身支持高并发，可以结合`goroutine`进行逻辑的并发处理
1. 数据库端
   	1. 读取数据进行Cache缓存。可以使用Memcache、redis进行数据的提前缓存。同时要注意缓存的命中率问题。
   	在数据更新时，尽可能的及时刷新缓存，保证命中率
 	1. 可以采用redis结合lua脚本保证数据的一致性
 	1. 可以采用数据库事务来进行原子性操作
 	1. 另外可以在应用程序层面, 通过操作后再次查询结果的方式，保证执行的结果
高并发的原则是在保证数据一致性的前提下尽可能的提高响应速度，保证可用性

### mysql的优化




### k8s


k8s是google开发的



