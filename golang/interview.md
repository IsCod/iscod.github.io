###值类型&引用类型传递

引用类型传递: `map`, `slice`, `interface`, `chan`, `pointer` 

值类型传递: `array`, `struct` ,`int`, `float`, `bool`, `string`

*make可以创建哪些*

```go
	var ch, sl, ma = make(chan int), make([]int, 0), make(map[int]int)
```

### 读写锁

golang的`sync`包提供了 互斥锁`sync.Mutex`和读写锁`sync.RWMutex`两种锁

`sync.Mutex`互斥锁，既不可同时运行。互斥锁有两个方法`Lock`和`Unlock`。通常在加锁有采用`defer`语句解锁。

`sync.RWMutex`读写锁，可以理解为`多读单写锁`。`读`是运行同时运行的，`写`是互斥的。一般有四种情况

读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。
写锁之间是互斥的，存在写锁，其他写锁阻塞。
写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。


### 协程和线程和进程的区别

* 进程

进程是系统资源分配和调度的最小单位，每个进程有自己的内存空间，不同进程之前通讯是通过进程通讯来完成

* 线程

线程是进程的一个实体，他是比进程更小的能独立运行的基本单位。线程间通讯最要通过共享内存，资源开销较小

* 协程

协程是一种用户态的轻量级线程，协程的调度是通过用户来进行控制的。协程拥有自己的寄存器上下文和栈（P）


线程是进程的一个实体

### GMP

* G: goroutine 调度实体, 既用户代码,   # 在本地队列中不断切换执行
* M: machine 内核线程, 既系统线程, 负责代码执行
* P: processor 逻辑处理器, 保存了调度上下文。也可以理解为局部的一个调度器。P的数量由`runtime.GOMAXPROCS`控制, 

每个p都有一个runqueue队列。p负责goroutine调度到`M线程`上运行。

除此之外呢，golang还维护一个全局的runqueue队列。


当某个p的本地runqueue队列运行完。首先 `p`就会从全局队列当中获取新的`goroutine`.

如果全局队列没有`goroutine`.

那么会从其它的`P`本地队列中偷一些`goroutine`(一半)


当某一个进程`M0`被阻塞时，P会找到一个新的`M1`进程上进行运行。
当被阻塞的`M0`返回`syscall`(既可以运行不阻塞了) `M0`会尝试获取一个`P`来继续运行。如果没有获取`P`，那么会将`MO`阻塞的`G`放入全局`runqueue`

### csp



### 如何退出`goroutine`

`goroutine`的退出一般有两种模式： 1.超时模式 2.关闭chan

超时模式是使用`time.After`启动了一个异步的定时器，返回一个 channel，当超过指定的时间后，该 channel 将会接受到信号

2，通过一个chan的关闭通知，进行`goroutine`的关闭 

### 什么情况下死锁，如何避免？

单个`goroutine`自读自写一个没有缓冲能力的`chan`

range `chan`时要注意关闭，如果不关闭一直阻塞


## 垃圾回收

#### 垃圾回收的三种算法

1. 引用计数

	每个对象维护一个引用计数, 当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。 [redis内存回收](https://iscod.github.io/#/nosql/redis?id=%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6)

	 redis就是采用的该种方法
2. 标记清除, 从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收
3. 分代收集

golang的垃圾回收是通过`GC`来实现的。

GC采用的理念是`三色标记`. `三色标记`可以理解成将一个内存标记为三种状态

1，白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收
2，黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象 以及从根对象可达的对象
3，灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象

垃圾回收的可以理解为三个步骤

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到不存在灰色对象；

当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾

### 反射

反射是通过`reflect`(ruifulekede)包来实现。它可以让程序操作不同类型的对象
`reflect`包提供了两个重要的接口`reflect.TypeOf` 和 `reflect.ValueOf`。TypeOf用来获取类型信息。ValueOf用来获取数据

 实现了运行时的反射能力，能够让程序操作不同类型的对象1。反射包中有两对非常重要的函数和类型，reflect.TypeOf 能获取类型信息，reflect.ValueOf 能获取数据的运行时表示

 ```go
 type User struct {
	Name string
	Age  int
}

func main() {
	u := User{Name: "ning", Age: 12}
	tp := reflect.TypeOf(u)
	va := reflect.ValueOf(u)
	for i := 0; i < tp.NumField(); i++ {
		fmt.Println(tp.Field(i).Name, "：", va.FieldByName(tp.Field(i).Name))
	}
}
 ```

### mysql的优化




### k8s


k8s是google开发的



