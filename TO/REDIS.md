# REDIS

## SET

- EX 秒设置指定的到期时间, 以秒为单位
- PX 毫秒-设置指定的到期时间, 以毫秒为单位
- NX 只有在密匙不存在的情况下才能设置密钥
- XX 只有在钥匙已经存在的情况下设置

```bash
127.0.0.1:6379> SET key "hello"
OK
```

设计模式

命令`SET resource-name anystring NX EX max-lock-time`是一种用Redis实现锁机制的简单方法, 如果返回OK那么获取锁成功, 并通过DEL命令释放锁. 客户端如果没有主动释放, 会在过期时间自动释放

可以使用如下优化

- 不设置固定的字符串, 而是设置为随机数的大字符串, 可以称为token
- 通过call删除

## 单Redis实例实现分布式锁

```bash
127.0.0.1:6379> SET resource-name random_value NX PX 30000
```

这个命令仅在不存在key的时候才能被执行成功 (NX选项), 并且这个key有30秒的自动失效时间 (PX属性), 这个key的值是一个"random_value"(一个随机字符串), 这个值在所有客户端必须是唯一的, 所有同一key的获取者, 这个值都不一样

value的值必须是随机数主要是为了更安全的释放锁, 释放锁的时候使用脚本告诉redis: 只有key存在的并且存储的值和我指定的值一样才能告诉我删除成功, 可以通过一下Lua脚本实现

```
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

使用这种方式可以释放锁可以避免删除别的客户端获取成功的锁. 
举个例子: 客户端A取得资源锁, 但是紧接着被一个其它操作阻塞了, 当客户端A允许完毕其它操作要释放锁时.
原来的锁早已超时并被redis自动释放, 并且在这期间资源锁又被客户B再次获取到. 如果仅使用`DEL`命令将key删除, 那么这种境况有把客户端B的锁给删除掉.
使用Lua脚本就不会存在这种情况, 因为脚本仅会在value等于客户端A的value时删除key (value相当于客户端的一个签名)

这个随机数应该怎么设置? 一般认为它是从`/dev/urandom`产生的一个20字节的随机数, 但是你也可以找到比这总方法代价更小的方法, 只要这个数在你的任务中是唯一的就行.
例如一种安全可行的方法是使用`/dev/urandom`作为RC4的种子和源产生一个伪随机流;另一种可行的方案是采用时间戳加和客户端ID再加一个小的随机的数拼接起来, 虽然理论上不安全, 但是多数情况下可以满足要求.

key的失效时间, 被称为"锁定有效时间", 它不仅是key自动失效时间, 而且还是一个客户端持有锁多长时间后可以被另外一个客户端重新获取.

截止目前我们有一个较好的方法获取锁和释放锁, 基于redis单实例, 假设这个单实例总是可用, 这个方法已经足够安全. 现在让我们扩展一下, 假设redis总是没有可用的保障


## Redlock算法

在Redis分布式环境中, 我们假设有N个Redis master, 这些节点完全独立, 不存在主从复制或者其他集群调度协调机制.
之前我们已经描述了单Redis实例下怎么安全的获取和释放锁. 我们确保将在每(N)个实例上使用此方法获取和释放锁. 我们假设有5个Redis master节点, 这是一个比较合理的设置, 我们需要5太机器上面或者5台虚拟机上面运行实例, 用以保证它们不会同时宕机.

为了获取到锁, 客户端执行以下操作:

- 获取当前时间戳, 以毫秒为单位
- 依次尝试从N个实例, 使用相同的key和随机值获取锁, 在步骤2, 当Redis设置锁时, 客户端应该设置一个网络连接和响应超时时间, 这个超时时间应该小于锁的失效时间, 假如你的锁自动失效时间是10秒, 则超时时间应该在5-50毫秒之间. 这样可以避免服务端Redis已经挂掉的情况下, 客户端还在死死等待响应结果, 如果没有在规定时间内响应, 客户端应该尽快尝试另外一个Redis实例
- 客户端使用当前时间减去开始获取锁时间 (步骤1的时间) 就得到获取锁使用的时间, 当且仅当从大多数 (这里是3个节点) 的Redis节点获取到锁, 并且使用的时间小于锁失效时间, 锁才算获取成功
- 如果取到了锁, key的真正有效时间等于有效时间减去获取锁所使用的时间 (步骤3)
- 如果因为某些原因, 获取锁失败 (没有在N/2+1个Redis实例取到锁或者取锁时间超过了有效时间), 客户端应该在所有的Redis实例上进行解锁 (即使在某些Redis实例根本没有加锁成功)

这个算法是异步的么?

## INCR

- 将key中的存储的数字值增加一。
- 如果key不存在那么初始化为0，然后在执行INCR操作
- 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。

## 计数器

计数器是 Redis 的原子性自增操作可实现的最直观的模式了，它的想法相当简单：每当某个操作发生时，向 Redis 发送一个 INCR 命令。

比如在一个 web 应用程序中，如果想知道用户在一年中每天的点击量，那么只要将用户 ID 以及相关的日期信息作为键，并在每次用户点击页面时，执行一次自增操作即可。

比如用户名是 peter ，点击时间是 2012 年 3 月 22 日，那么执行命令
```bash
127.0.0.1:6379> INCR peter::2012.3.22
```

可以用以下几种方式扩展这个简单的模式：

- 可以通过组合使用 INCR 和 EXPIRE ，来达到只在规定的生存时间内进行计数(counting)的目的。
- 客户端可以通过使用 GETSET 命令原子性地获取计数器的当前值并将计数器清零，更多信息请参考 GETSET 命令。
- 使用其他自增/自减操作，比如 DECR 和 INCRBY ，用户可以通过执行不同的操作增加或减少计数器的值，比如在游戏中的记分器就可能用到这些命令。

## 限速器

限速器是特殊化的计算器，它用于限制一个操作可以被执行的速率(rate)。

限速器的经典用法是限制公开的API的请求次数，以下是一个限速器时间实例，它将API的最大请求限制在每个IP地址每秒钟十个之内。

```php
<?php
  $ip = get_api_ip();//获取用户ip函数 
  $key = 'SECOND_REQUERY_NUM:' . $ip;
  $requery_num = $redis->lLen($key);
  if ($requery_num > 10) {
      die('Too many requey second');
  }
if (!$redis->existes($key)) {
  $redis->rPush($key, $ip);
  $redis->expire($key, 1);
}
  $redis->rPushx($key, $ip);
  echo 'ok';
?>
```

限速器使用列表结构作为容器,$redis->lLen()检查列表中记录的访问次数，第二个if语句用于第一次访问时，执行计数和创建列表，并且设置过期时间，最后的$redis->rPushx在后续的计数中进行增加操作。


## 缓存

### 缓存穿透与缓存雪崩

*缓存穿透*

缓存穿透是指，缓存和数据库都没有的数据，被大量请求。由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。
对空结果也进行缓存可以防止一定的缓冲穿透问题。

*缓存雪崩*

缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。

防止缓存雪崩普遍采用的是对过期时间加上随机值，避免同时过期。例如[rockscache](https://dtm.pub/app/cache.html#%E9%98%B2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9)


