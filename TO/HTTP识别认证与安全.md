# HTTP识别认证与安全

## 客户端识别与 COOKIE 机制

web服务器可能会同时与成千上百个客户端进行对话, 这些服务器通常需要记录下它们与谁交谈, 而不会认为所有的请求都来自匿名客户端

然而, HTTP最初是一个匿名, 无状态的请求响应协议. 服务器处理来自客户端的请求, 然后向客户端回送一条响应. web服务器几乎没有什么信息可以判断是那个用户发送的请求, 也无法记录来访用户的请求序列

现代的web站点希望能够提供一些个性化的展示, 并且能在客户浏览的时候做进行一些跟踪. 进而提供一下个性的服务, 例如:

- 个性化的问候
- 有的放矢的推荐
- 管理信息的存档
- 记录会话等

HTTP 不是天生就具有丰富的识别特性, 早期的web站点设计者都有自己的用户识别技术, 每种技术也各有优势和劣势, 常见的早期用户识别技术, 如:

- 承载用户身份信息的 HTTP 首部
- 客户端 IP 地址跟踪（通过用户的 IP 地址对其进行识别）
- 用户登录（用认证方式来识别用户）
- 胖 URL（一种在URL中嵌入识别信息的技术）
- cookie（一种功能强大且高效的持久身份识别技术）

### HTTP首部

常见的承载用户相关信息的 HTTP 首部, 如:

 HTTP首部     |  首部类型  | 描述
------------- | -------- | -------------------------------
From          |    请求   | 用户的E-mail地址
User-Agent    |    请求   | 用户的浏览器软件
Referer       |    请求   | 用户是在这个页面上依照连接跳转过来的
Authorization |    请求   | 用户是在这个页面上依照连接跳转过来的
Client-ip     | 请求(扩展) | 客户端的IP地址
Cookie        | 请求(扩展) | 服务器产生的ID标签

**From** 包含了用户的E-mail地址, 每个用户都有不同的E-mail地址, 所有在理想情况下可以将这个地址作为可行的源端来识别用户. 但由于担心不道德的服务器会收集这些E-mail地址, 用于垃圾邮件散发所以很少有浏览器会发送From首部

**User-Agent** 首部可以将用户浏览器的相关信息告知服务器, 包括程序的名称和版本, 操作系统等相关信息. 要实现特定浏览器及其属性的良好互操作时, 这个首部非常有用. 但是它并没有为识别特定用户提供太多有意义的帮助. 下面是Google的Chrome浏览器发送的一种User-Agent首部信息

```
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
```

**Referer** 首部提供了用户来源页面的URL, **Referer** 首部能很好的理解用户的浏览行为, 以及用户的兴趣所在, 但并不能完全用于标识用户. 比如用户是从某个购物网站进入到你的web站点，那么他可能喜欢购物等

**From**, **User-Agent**, **Referer** 都不能提供可靠的用户识别机制, HTTP需要更可靠的用户识别机制, 如**客户端IP**、**用户登录**, **cookie**等

### 客户端IP

早期的web开发者曾尝试使用客户端IP作为一种用户标识技术使用. 如果每个用户都有不同的IP地址, 同时IP地址也很少发生变化, 并且服务器可以判断出每条请求的客户端IP地址, 那么这种方案是可行的. 但是使用客户端IP有很多缺点, 限制了其作为用户识别技术的效能, 例如:

- **客户端IP** 描述的是所用的机器, 而不是用户. 如果多个用户使用同一台机器, 那么就无法区分是哪个用户了
- 很多网络提供商都会在用户登录时为其分配动态IP地址, 用户每次登录都会得到以一个不同的地址, 因此web服务器不能假设IP地址在各登录会话之间标识用户
- 为了提高安全, 并对稀缺得地址资源进行管理, 很多用户是通过网络地址转换 (NAT) 防火墙来浏览内容, 这些NAT防火墙隐藏了防火墙后哪些实际客户端IP地址, 将实际客户端IP地址转换成了一个共享的防火墙IP (和不同的端口)
- HTTP代理和网关通常会打开一个新的, 到原始服务器的TCP连接, web服务器将看到的是代理服务器的IP而不是客户端的

### 用户登录

web服务器无需被动的根据用户的IP地址猜测他的身份, 它可以要求用户通过用户名和密码来显式的询问用户是谁

HTTP包含了一种内建机制, 可以用**WWW-Authorization**和**Authorization**首部向web站点传送用户的相关信息, 一旦登录, 浏览器可以不断地在每条发往这个站点的请求中添加登录信息了, 这样就总是有登录信息可用了

但是登录多个站点是很繁琐的, 小明从一个站点浏览到另一个站点时需要在每一个站点登录, 更糟糕的是, 用户可能要为不同的站点记住不同的用户名和密码

用户访问其它站点时可能喜欢使用的用户名已经被其他人使用了, 而且不同的站点为用户名和密码设置了不同的规则, 那么用户很可能会很快放弃上网了

### 胖URL

有些web站点会为每个用户生成特定的URL来追踪用户身份. 通常会对真正的URL进行扩展, 在URL路径开始或结束的地方添加一些状态信息. 用户浏览站点时, web服务器会动态生成一些超链, 维持URL中的状态信息

这些包含了用户信息状态的URL 被称为胖URL, 用户首次访问web站点时, 可以生成一个唯一的ID, 用服务器可以识别的方式, 将这个ID添加到URL中去, 然后服务器就会将客户端重新导向这个胖URL

用户浏览站点时, 用胖URL对其进行识别, 看似可行. 但这个技术有几个严重的问题

- 丑陋的URL 

  胖URL包含了特定的用户和会话有关的状态信息, 如果将这个URL发送给别人, 那也无意中将你个人信息共享出去了

- 破坏缓存

  为每个URL生成用户特有的版本意味着不再有可供公共访问的URL需要缓存了

- 额外的服务器负荷

  服务器需要重写HTML页面使用胖URL

- 在会话间是非持久的

  除非用户收藏了特定的胖URL, 否则用户退出登录时, 所有信息丢失

### COOKIE

**cooike** 是当前识别用户, 实现持久会话的最好方式. 前面几种技术的很多问题对它们都没有影响, 但是通常会将它们与那些技术共用. **cookie** 非常重要, 而且它们定义了一些新的HTTP首部, 但是cookie的存在也影响了缓存, 大多数缓存和浏览器都不允许对任何cookie的内容进行缓存, 后面我们会详细进行介绍

**cookie类型**

可以笼统的将cookie分为两类: **会话cookie**和**持久cookie**

**会话cookie**是一种临时cookie, 它记录了用户访问站点的设置和偏好, 用户退出浏览器时会话cookie就会被删除了. **持久cookie**的生存时间更长一些, 他们存储在硬盘上, 浏览器退出, 计算机重启时他们仍然存在, 通常会用持久cookie维护某个用户会周期访问的站点配置文件或登录名

**会话cookie**与**持久cookie**的唯一区别就是它们的过期时间如果设置了DisCard参数或者没有设置Expires或者Max-Age参数来说明扩展的过期时间, 这个cookie就是一个会话cookie

**cookie是如何工作的**

cookie就像是服务器给用户贴的便签纸. 用户访问web站点时, web站点就可以读取那个服务器贴到这个用户身上的所有贴纸.

用户首次访问web站点时, web服务器对用户一无所知, 但是wab站点希望用户会再次回来, 于是给用户贴上一个独一无二的cookie, 这样以后就可以识别出这个用户了. 

cookie中包含了一个由 名字=值(name=value) 这样的信息构成的任意列表, 并通过*Set-Cookie*或者*Set-Cookie2*HTTP响应(扩展)首部将其贴到用户身上. 浏览器会记住从服务器返回的*Set-Cookie*或者*Set-Cookie2*首部中的cookie内容, 并将其集中在浏览器的cookie数据库中. 在用户访问同一站点时, 浏览器会挑中那个服务器贴到用户身上的cookie, 并在一个cookie请求首部中发送给web服务器

**cookie与缓存**

缓存那些cookie事务要特别小心, 你不会希望给用户分配一个用过的cookie, 或者是向一个用户展示其他人的私有文档. 糟糕的是cookie和缓存的规则没有很好的建立起来, 只有一些指导性的规则:

- 如果无法缓存文档, 要将其标示出来
- 缓存*Set-Cookie*首部时要小心
- 小心处理带有*Cookie*首部的请求

### Cookie, 安全性和隐私

*Cookie*是可禁止的, 而且可以通过日志分析或其它方式来实现大部分跟踪记录, 所以Cookie自身并不是很大的安全隐患. 实际上可以通过提供一个标准的审查方法在远程数据库中保存个人信息, 并将匿名Cookie作为键值, 来降低客户端到服务器的敏感数据传输频率.但是潜在风险总是有的, 所以在处理隐私和用户跟踪信息时, 最好是小心一些

## 基本认证机制

认证是需要用户给出一些身份证明, 比如一个人给出了像护照或者驾照那样的信息, 就给出了一些证据, 说明你是声称的那个人. 在自动取款机(ATM)上输入密码, 或者在计算机系统的某个对话框输入密码时, 也是在证明你是声称的那个人

但是这些策略都不是最有效的, 密码可以被猜出来, 或者被人偶然听到, 身份证件可能被盗, 但每种证明都有助于构建合理的信任, 来证明你是声称的那个人

### 基本认证

基本认证是最流行的HTTP认证协议. 几乎每个主要的客户端和服务器都实现了基本认证机制. 基本认证是最初在 HTTP/1.0 规范中提出

在基本认证中, web服务器可以拒绝一个事务, 质询客户端, 请求用户提供有效的用户名和密码. 服务返回401状态码, 而不是200状态码来初始化认证质询, 并用*WWW-Authenticate*响应首部指定要访问的安全域. 浏览器收到质询会打开一个对话框, 请求用户输入这个域的用户和密码. 然后将用户名和密码稍加扰码, 再用*Authenticate*请求首部回送给服务器

### 基本认证的缺陷

基本认证简单便捷, 但并不安全. 只能用它防止非恶意用户的无意间访问或将其与ssl这样的加密技术配合使用

基本认证存在以下安全缺陷:

- 基本认证会通过网络发送用户名和密码, 这些用户名和密码都是一种很容易解码的形式表示
- 即便密码是以更难解码的方式加密, 第三方用户仍然可以捕获被修改过的用户名和密码, 并将修改过的用户名和密码一次次重放给原始服务器, 以获得相应的访问权限, 没有什么措施可以防止这种重放攻击
- 即使将基本认证用于一些不重要的应用程序, 比如公司内部网络的访问控制, 一些不良习惯也会让它变得很危险
- 基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施
- 假冒服务器很容易骗过基本认证, 如果用户实际链接到一台恶意服务器或者网关的时候, 能够让用户相信他链接的是一个受基本认证保护的合法主机, 攻击者就可以请求用户输入密码, 并将其保存起来, 然后捏造一条错误信息传给用户

## 摘要认证

基本认证便捷灵活，但是极不安全, 用户名和密码都是明文传输, 也没有采取任何措施防止对报文的篡改. 安全使用基本认证的唯一方式是与ssl结合

摘要认证与基本认证兼容, 却更为安全. 摘要认证是另一种HTTP认证协议, 它试图修复基本认证协议的严重缺陷, 具体来说, 摘要认证进行了如下改进

- 永远不会以明文方式在网络上发送密码
- 可以防止恶意用户捕获并重放认证的握手过程
- 可以有选择的防止对报文的篡改
- 防范其它几种常见的攻击方式

摘要认证并不是最安全的协议, 摘要认证并不能满足安全HTTP事务的很多需求. 对这些需求来说, 使用传输层安全 (TLS) 和安全HTTP (HTTPS) 协议更为合适一些

### 用摘要保护密码

摘要认证的箴言是"绝不通过网络发送密码", 客户端不会发送密码, 而是会发送一个指纹或者密码的摘要, 这是密码的不可逆扰码

客户端和服务端都知道这个密码, 因此服务端可以验证客户端所提供的摘要与密码是否匹配, 只拿到摘要的话, 除了拿所有的密码来试试之外, 没有那个方法可以找出摘要是那个密码的!

### 单向摘要

摘要是 "对信息主体的浓缩", 摘要是一个单向函数, 主要是用于将无限的输入值转换为有限的浓缩输出值, 常见的摘要函数MD5, 会将任意长度的字符序列转换为一个128位的摘要

128位 = 2的128次方, 或者大约 1000 000 000 000 000 000 000 000 000 000 000种不同的输出值

对于摘要来说, 最重要的是如果不知道密码的话, 想要正确的猜出发送服务器的摘要是非常困难的. 同样如果要判断出是它是无限输入值中的那一个产生的也是相当困难

MD5输出的128位摘要通常会被写成32个十六进制的字符, 每个字符表示4位. 理论上讲我们将无限输入的值转成了有限的输出值, 那么两个不同的无限值就可能映射为同一个摘要, 这种情况被称为*冲突*, 实际上由于可用的输出值足够大, 在现实生活中出现冲突的概率微乎其微

?> 有时摘要函数称为加密的校验和, 单向散列函数或指纹函数, SHA是另一种常见的摘要函数

### 用随机数防止重放攻击

使用单向摘要就无需以明文形式发送密码了, 只发送密码的摘要, 而且可以确信没有哪个恶意用户能轻易的从摘要中解码出原始密码

但是即使隐藏密码并不能避免危险, 因为即使不知道密码也可以截取摘要, 并一遍遍的重放给服务器, 摘要和密码一样好用

为防止重放攻击的发生, 服务器可以向客户端发送一个随机数 (nonce)的特殊令牌, 这个数经常发生变化, 客户端在计算摘要之前要将这个随机令牌附加到密码上去

在密码中加入随机数就会使摘要随着随机数的每一次变化而变化, 记录下的密码摘要只对特定的随机数有效, 而没有密码的话, 攻击者就无法计算出正确的摘要, 这样可以防止重放攻击

摘要认证要求使用随机数, 因为这个小小的重发弱点会使未随机化的摘要认证变的和基本认证一样脆弱

?> 很多web应用会使用一个名为token的随机字符串附加到密码上去

### 摘要认证的握手机制

HTTP摘要认证是一种升级的认证方式, 所有首部认证与基本认证类似, 它在传统首部中添加了一些新的选项, 还添加了一个新的可选首部Authorization-Info

三步握手机制

- 服务器计算出一个随机数, 服务器将这个随机数放在www-Authenticate质询报文中, 与服务器所支持的算法列表一同发送给客户端
- 客户端选择一个算法, 计算出密码和其它数据的摘要, 将摘要放在一条Authorization报文中发回服务器, 如果客户端要对服务器进行认证, 可以发送客户端随机数
- 服务端接收摘要, 选中的算法以及支撑数据, 计算出与客户端相同的摘要, 然后服务器将本地生成的摘要与网络传送过来的摘要进行比较, 验证其是否匹配

如果客户端反过来用客户端随机数对服务器进行质询, 就会创建客户端摘要. 服务器可以预先将一个随机数计算出来, 提前将其传递给客户端, 这样下一次客户端就可以预先发送正确的摘要了

### 预授权

在普通的认证方式中, 事务结束前, 每条请求都要求有一次请求/质询的循环, 如果客户端事先知道下一个随机数是什么, 就可以取消这个请求/质询循环

预授权对基本认证来说并不重要 (很常见) , 浏览器通常会维护一些客户端数据一存储用户名和密码, 一旦用户与某个站点进行了认证, 浏览器通常为后续的请求发送正确的Authorization首部

摘要认证由于使用了随机数技术破坏了重放攻击, 所以对于摘要认证预授权要复杂一些

摘要认证提供了以下几种预授权方式

- 服务器预先在Authorization-Info成功首部中发送下一个随机数
  
  可以在Authorization-Info成功首部中将下一个随机数预先提供给客户端, 这个首部是与前一次成功认证的200 OK响应一同发送的
```
Authorization-Info: nextnonce="<nonce-value>"
```
  这样客户端就可以预先发布Authorization首部了, 这种机制避免了请求/质询循环 (加快了事务处理的速度), 但实际上它破坏了对同一台服务器多条请求的管道化功能 (管道化是避免延迟的一项基本技术), 所以这样可能造成很大的性能损失

- 服务器允许在一小段时间内使用同一个随机数
  
  另一种方式是允许随机数重用, 比如服务器可能允许某个随机数重用5次, 或者10秒, 由于随机数是事先知道的, 就可以对请求进行管道化, 随机数过期时服务器向客户端发送 401 Unauthorized 质询并设置www-Authenticate=true指令

  重用随机数使得攻击者更容易实现重放攻击, 虽然这降低了安全性, 但是重用随机数的生命周期是可控的, 所以应该可以找到安全与性能的平衡点

- 客户端与服务端使用同步的, 可预测的随机数生成算法
  
  还可以采用时间同步的随机算法, 客户端和服务期可以根据共享的密钥, 生成第三方无法轻易预测的, 相同的随机数序列 (比如安全ID卡)

  这些算法超出了摘要认证的范畴
  
### 报文完整性保护

## 安全的HTTP

基本认证, 摘要认证和报文完整性检查对于一般的网路事务来说很好用, 但是对于大规模的购物银行事务, 或者对访问机密数据来说, 并不够强大

这些更重要的事务需要将HTTP和数字加密技术结合使用才能确保完全

HTTP的安全版本需要高效可移植且易于管理并且提供下列功能

- 服务器认证 (客户端知道它们是与真正的而不是伪造的服务器通话)
- 客户端认证 (服务器知道它们是与真正的而不是伪造的客户端通话)
- 完整性 (客户端与服务器的数据不会被修改)
- 加密 (客户端与服务器的对话是私密的, 无需担心被窃听)
- 效率 (一个运行足够快的算法, 以便低端的客户端和服务器使用)
- 普适性 (基本上所有的客户端和服务器都支持这种协议)
- 管理的可扩展性 (在任何地方的任何人都可以立即建立安全通信)
- 适应性 (能够支持当前最知名的安全方法)
- 在社会的可行性 (满足社会的政治文化需求)

### HTTPS

HTTPS是目前最流行的HTTP安全形式, 由网景公司首创, 所有主要的浏览器和服务器都支持该协议. HTTPS 方案的URL开头是`https://`而不是`http://`开头, 可以根据方案确定使用的是HTTPS还是HTTP

使用HTTPS时, 所有的HTTP请求和响应数据在发送到网络前都进行了加密, HTTPS在HTTP协议下面提供一个传输级的密码安全层, 一般使用SSL或者TLS. 由于大部分困难的编码和解码工作由SSL库完成, 所以web客户端和服务器在使用安全的HTTP时无需做太多的修改协议处理逻辑. 大多数情况下, 只需要用SSL的输入/输出调用取代TCP的调用, 再增加几个调用来配置管理安全信息就可以了

介绍HTTPS之前，我们了解一下SSL和HTTPS用到的加密编码技术背景知识

- 密码 (对文本进行编码，使偷窥者无法识别的算法)

- 密钥 (改变密码行为的数字化参数)

- 对称密钥加密系统 (编/解码使用相同密钥的算法)

- 公开密钥加密系统 (一种能够使数百万计算机便捷地发送机密报文的系统)

- 数字签名 (用来验证报文未被伪造或篡改的校验和)

- 数字证书 (由一个可信的组织验证和签发的识别信息)

### 数字加密

**密码编制的机制和技巧**

密码学是对报文进行编/解码的机制和技巧, 密码学不仅仅是加密报文以防止好事者读取, 还可以用它来防止对报文的篡改, 甚至可以用密码学来证明某条报文或某个事务确实出自你手

**密码**

密码学基于一种名为密码的的秘密代码, 密码是一套编码方案 - 一种特殊的报文编码方式和一种稍后使用的相应解码方式的结合体, 加密之前的原始报文称为**明文**, 使用了密码之后的报文称为**密文**

用密码生成保密信息已经有千年历史，传说凯撒曾使用一种三字符循环位移密码，报文中的每个字符都由字母表中三个位置之后的字符来取代，这种位移密码演变出多种方法比如维吉尼亚密码等。

密码    | | | |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
------- |---------------------------------------------------------
转换字符 |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|A|B|C


明文 | MNT ME AT THE AT
--- | -------------------
密文 | PHQW PH DW WKM DW


**密码机**

最初, 人们需要自己进行编码和解码, 所以期初的密码也是相当简单的算法. 因为密码相当简单, 破解这种密码也相当容易

随着技术的进步, 人们开始执照一些机器, 这些机器可以用复制得多的密码来快速精确的对报文进行编解码, 这些密码机不仅能做一些简单的旋转, 它们还可以替换字符改变字符顺序, 将报文切块, 使代码的破解更加困难

?> 最著名的密码机可能是二战期间的Enigma编码机了, 你应该在电影中经常见到, 尽管Enigma非常复制, 但是阿兰·图灵和他们同事以及芬兰的工作者还是使用了最早的计算机破解Enigma代码了, 这是一段非常精彩的加密与破解密码的对抗赛

**使用了密钥的密码**

编码算法与编码机都可能会落入敌人手中, 所以大部分的机器上都有一些号盘, 可以将其设置为大量不同的值以改变密码的工作方式, 即使机器被盗, 没有正确的号码盘设置(密钥值), 解码器也无法工作

这些密码参数被称为密钥 (key). 要在密码盘机中输入正确的密钥, 解码过程才能正确进行, 密码密钥会让一个密码机看起来好像是多个虚拟的密码机一样, 每一个密码机都有不同密钥值, 因此其以为会有不同

**数字密码**

随着数字计算的出现, 出现了以下两个主要的进展

- 从机械设备的速度和功能限制中解放出来, 使复杂的编/解码算法成为可能
- 支持超大密钥成为可能, 这样就可以从一个加密算法中产生出数万亿的虚拟加密算法, 由不同的密钥值来区分不同的算法. 密钥越长, 编码组合就越多, 通过随机猜测密钥来破解代码就越困难

与金属钥匙或机械设备中的号盘设置相比, 数字密钥只是一些数字. 这些数字密钥值是编/解码算法的输入. 编码算法就是一些函数, 这些函数会读取一块数据, 并根据算法和密钥值对其进行编/解码

### 对称密钥加密技术

很多数字加密算法被称为对称密钥加密技术, 这是因为他们在编码时使用的密钥和解码时的一样. 我们统称为秘钥K

在对称秘钥加密技术中, 发送端和接收端要共享形同的秘钥K才能进行通信. 发送端用共享秘钥来加密报文, 并将得到的密文发送给接收端. 接受端收到密文, 并对其应用解密函数和相同的密钥, 恢复出原始明文

?> 流行的对称密钥加密算法包括: DES、Triple-DES、RC2和RC4

**密钥长度和枚举攻击**

保持密钥的保密状态是很重要的, 在很多情况下, 编/解码算法是众所周知的, 因此密钥就是唯一保密的东西了

好的加密算法会迫使攻击者试遍每一个可能的密钥, 才能破解代码. 用暴力去尝试所有的密钥值被称为**枚举攻击**. 如果只有几种可能的密钥值, 居心不良的人通过暴力遍历所有的值, 就成功破解代码了. 如果有大量的密钥值, 他可能需要花费数天, 数年, 甚至无限长的时间来遍历所有的密钥, 去查找能够破解密码的那一个

可用密钥值的数量取决于密钥中的位数, 以及可能的密钥中有多少是有效的. 
就对称密钥加密技术来说, 通常所有的密钥值都是有效的. 8位的密钥只有256个可能的密钥值, 40位的密钥有大约一万亿个密钥, 128位的密钥可以产生大约340 000 000 000 000 000 000 000 000 000 000 000 000个可能 的密钥值。

在传统的对称密钥加密技术中, 对小型的、不太重要的事务来说40位密钥就足够安全了, 但现在的高速工作站每秒可以进行数十亿次计算, 可以轻松对其进行暴力破解

相对之下, 128位的密钥被认为是非常强大的, 实际上长密钥对密码安全非常重要. 根据1995的微型处理器

**建立共享密钥**

对称密钥加密技术的缺点之一是发送者与接收者在相互对话之前, 一定要有一个共享的保密密钥, 如果N个节点, 每个节点都要和其它所有N-1个节点进行安全对话, 那么需要N的平方个保密密钥, 这对管理非常困难

### 公开密钥加密技术

公开密钥加密技术没有为每对主机使用单独的加密/解密密钥, 而是使用了两个非对称密钥, 一个用来对主机报文编码, 另一个用来对主机报文进行解码. 编码密钥是众所周知的 (也就是公开密钥加密这个名字的由来), 但只有主机才知道私有的解密密钥. 这样, 每个人都能找到某个特定主机的公开密钥, 密钥的建立变得更加简单. 但是解码的密钥是保密的, 因此只有接收端才能对发送给它的报文进行解码

**RSA**

所有公开密钥非对称加密系统所面临的共同挑战是，要确保即使有人拥有了下面所有的线索，也无法计算出保密的私有密钥：

- 公开密钥（是公开的，所有人都可以获取）
- 一小片拦截下的密文（可通过对网络的嗅探获取）
- 一条报文与之相关的密文（对任意一段文本运行加密器就可以得到）

RSA算法就是满足了所有这些条件的流行的公开密钥加密系统, 它是在MIT发明后由RSA数据安全公司将其商业化. 即使有了上述所有条件, RSA算法自身, 甚至RSA实现的源代码, 破解代码找到相应的私有密钥的难度仍相当于对一个极大的数进行质因子分解的困难程度, 这被认为是所有计算机科学中最难的问题之一. 因此如果你发现一种快速将一个极大的数分解为质因数的方法, 不仅能够入侵瑞士银行账户系统, 而且可以获得图灵奖了

### 数字签名

以上我们讨论了使用对称和非对称密钥加/解密保密报文的密钥加密技术

除了加/解密报文之外, 还可以对报文进行签名（sign）, 用以说明是谁编写的报文, 同时证明报文没有被篡改过. 这种技术称为: *数字签名*

*签名*是附加在报文上的特殊加密校验码, 使用数字签名有以下两个好处

- 签名可以证明是作者编写了这条报文
- 签名可以防止报文被篡改

数字签名通常是用于非对称公开密钥技术产生的. 因为只有所有者才知道其私有密钥, 所以可以将作者的私有密钥当做一种"指纹"使用

举个例子：

- 节点A将边长报文提取为定长的摘要
- 节点A对摘要应用了一个"签名"函数, 这个函数会将用户的私有密钥作为参数, 因为只有用户才知道私有密钥, 所以正确的签名函数会说明签名者就是其所有者
- 一单计算出签名, A节点就将其附加在报文末尾, 并将报文和签名发送给B
- 在接收端, 如果B节点需要确定报文确实是A节点写的, 而且没有被篡改过, B可以对签名进行检查. B接收到私有密钥扰码的签名, 并应用了使用公开密钥的反函数, 如果拆包后的摘要与节点B自己的摘要版本不匹配, 要么是报文在传输过程中被篡改了, 要么是发送端没有节点A的私有密钥（也就说不是A节点）

### HTTPS

*HTTPS*是常见的HTTP安全版本, 它得到了广泛的应用, 所有主流的商业浏览器和服务器上都实现了HTTPS

HTTPS是在安全的传输层上发送的HTTP, HTTPS没有将未加密的HTTP报文发送给TCP, 它在将HTTP报文发送给TCP之前, 将其发送给一个安全层, 对其进行加密

?> HTTP安全层是通过SSL及其替代协议TLS来实现

**建立安全传输**

在未加密的HTTP中,客户端会打开一条连接到web服务器端口80的tcp连接, 发送一条报文, 接受一条响应报文, 关闭连接

由于SSL安全层的存在, HTTPS中客户端首先打开一条到web服务器443端口(HTTPS默认端口)的连接, 一旦建立了TCP连接, 客户端和服务端就会初始化SSL层, 对加密参数进行沟通, 并交换密钥. 握手完成之后, SSL初始化就完成了, 客户端就可以将请求发送给安全层了. 将这些报文发送给TCP之前, 对其进行加密


