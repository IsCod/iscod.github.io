# 并发不是并行

理解并发与并行的区别首先想到的是如下的程序执行图：

![并发&并行](https://iscod.github.io/images/cp1.png)

> 并发是同时处理很多事情（事件是交叉处理的）。并行是同时做很多事情（事情是并行处理的）

## 并发（Concurrency）

定义：并发是指系统能够在同一时间段内管理多个任务的执行，但不要求这些任务同时执行。
它可以是任务交替进行的，比如任务 A 运行一段时间，然后切换到任务 B，再切换回任务 A。这是一种任务之间切换的机制。

特点：在单核 CPU 上，并发可以通过任务的快速切换来模拟多个任务的同时进行。多个任务共享同一处理器，通过操作系统调度器决定何时执行哪个任务。

应用场景：当系统需要处理 I/O 密集型任务（如网络请求、文件读写）时，任务之间可以在等待时互相交替执行，从而提高效率。

类比：一个人同时处理多项工作，例如看书和听音乐。虽然他们不能完全同时进行，但可以快速在两者之间切换。

## 并行（Parallelism）

定义：并行指的是多个任务在同一时刻同时执行。并行依赖于多核 CPU 或多台机器，因为每个核心或机器可以独立处理一个任务。

特点：在真正的并行执行中，不同的任务可以完全独立、同时运行，彼此之间互不影响。这通常适用于 CPU 密集型任务。

应用场景：当系统拥有多核处理器时，可以同时运行多个计算密集型任务，如科学计算、大数据处理等。

类比：两个人同时进行两项工作，比如一个人看书，另一个人听音乐，他们可以真正同时进行工作。

### goroutines

goroutines是并发执行的关键

### channels

channels实现同步与消息的传递

### select 

多路并发控制

## 并行




思考如下程序的输出

```go
func Num(proc int) int {
	runtime.GOMAXPROCS(proc)
	var count int
	wg := sync.WaitGroup{}
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			count += 1
			wg.Done()
		}()
	}
	wg.Wait()
	return count
}

func main() {
	fmt.Println(Num(1), Num(2)) //输出: 1000 985
}
```