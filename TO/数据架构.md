# 数据架构

## 分库分表

## 订单ID

订单ID生成的一种典型方式是使用时间戳加上一个随机数

典型订单ID结构

时间戳     | 随机数字
--------- | ------
time      | rand

```php
<?php
function getPayNo()
{
	return date('YmdHis') . rand(1000, 9999);
}
```

这样的结构有一个致命弱点, 即不能100%确保订单ID的唯一性. 虽然看起来在每秒小数据量的情况下可行, 但是在处理大数据量的情况下, 唯一性更难保证, 虽然增加rand的集合看起来可以解决大量订单的情况, 但是还是无法从根本上解决随机数重复出现问题

?> 经过测试悲观情况下上述随机数集在每秒二十次的请求时就会产生重复数据, 所以不要轻易相信这种订单结构生成方式

另一种方式是使用数据库的自增Id来保证唯一性, 虽然可以解决上面随机数的重复性问题, 但是在订单量达到每秒万级别的时候, 数据库性能很难满足, 并且当面临分布式数据架构时数据一致性问题也很难处理, 所以使用数据库自增ID并不会是最好的选择

还有一种方式就是时间戳接合内存 (Redis) 的自增序号获取唯一的订单ID

采用时间戳和内存自增序号订单ID结构:

时间戳     | 机器编号 | 自增序号
--------- | ------- | ------
time      | 1       | incr

- 时间戳 (精确到秒)
- 机器编号 (每个数据服务器都设置一个唯一编号)
- 自增序列 (当在同一时间同一台服务器有多个订单时, 在当前时间戳下自增此序号, 下一秒序号继续从1开始)

```php
<?php
function getPayNo($server_id)
{
	$time = date('YmdHis');
	$incr = $redis->incr($time);
	return $time . $server_id . $incr;
}
```


### 最终一致性


## 数据库高可用

所谓的数据库高可用指的是: 当数据库由于各种原因出现问题时, 能实时或者快速的恢复数据库服务并修补数据, 从整个集群的角度看, 就想没有出现任何问题一样

?> 恢复数据不一定是修复原有数据库, 也可以是切换到其它备库

数据库高可用的主要工作是数据库恢复与数据修补, 一般以完成这两项工作的时间长短来衡量高可用的好坏

?> 数据库恢复的时间越长, 不一致数据会越多, 数据修补的时间就会越长, 整体的修复时间也会变长, 这是一个恶性循环, 所以快速修复数据是数据库高可用中的重点

**经典主从同步结构:**

![经典主从结构](https://iscod.github.io/images/mysql_master_slave_1.png)

经典结构的一大弊病是, 不管主库还是从库一但出现问题, 都需要web应用系统配合完成数据恢复工作, 自动化困难, 恢复过程相当缓慢


**主从高可用结构:**

![主从高可用结构](https://iscod.github.io/images/mysql_master_slave_2.png)


web应用不与Master和Slave库直接连接, 而是连接KeepLive虚拟出的IP和Lvs, KeepLive将此虚拟IP映射到主库Master上, 主库Master有一个备用Master从库, 实时同步数据. 正常服务时web在Master读写数据, 当Master宕机时, 虚拟IP自动映射到Master从库, 这样只需要几秒, 就能完成数据恢复





### 数据分级


### 粗细管道