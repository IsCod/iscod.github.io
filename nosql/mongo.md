# MongoDB

## 数据类型

### 基础数据类型

在概念上，MongoDB的文档与Javascript中的对象相近，因而可认为它类似于[JSON](https://www.json.org/json-zh.html)。[JSON](https://www.json.org/json-zh.html)是一种简单的数据表示方式，其仅包含6中数据类型，易于理解、分析、记忆。另一方面来说，因为他仅仅包含 null、布尔、数字、字符串、数组和对象这几种类型。所有JSON的表达能力有限。

MongoDB在保留JSON基本键/值对特性基础上，添加了其他一些数据类型

- null

null用于表示空值，或者不存在的字段

```bson
{"x": null}
```

- bool

布尔类型有俩个值 true和false

```bson
{"a":true}
```

- 数值

sell默认使用64位浮点型数值，因此以下数值在shell是很正常的:

```bson
{"x": 3.14}
{"x": 3}
```

对于整型值，可以使用`NumberInt`或`NumberLong`类

```bson
{"x": NumberInt("1")}
{"x": NumberLong("1")}
```

- 字符串

UTF-8字符串都可以表示为字符串类型的数据

```bson
{"x": "iscod"}
```

- 二进制数据

二进制数据是一个任意字节的字符串，它不能直接在sell中使用。如果要将非UTF-8字符保存到数据库中，二进制是唯一选择

- 日期

日期被用于存储为自新纪元以来经过的毫秒数，不存储时区

```bson
{"x": new Date()}
```

- 数组

数组是一组值，它既能作为有序对象（如列表、栈和队列），也能作为无序对象（如数据集）来进行操作。

```bson
{"x": ["a", "b", "c"]}
```

- 内嵌文档


文档可以作为键的值，这样的文档就是内嵌文档。使用内嵌文档可以使数据组织更加自然，不用非得存成扁平结构的键/值对。
例如，用文档表示用户信息，同时需要保存用户地址信息，就可以将地址信息保存在内嵌的 “address” 文档中。

```bson
{"name": "iscod", "address" : { "city": "shanghai", "district": "pudong"}}
```



### `_id`和`ObjectId`

MongoDB中存储的文档必须有一个`_id`键。这个键值可以是任何类型的，默认是个`ObjectId`对象。
在一个集合里面，每个文档都有一个唯一的`_id`，确保集合里每个文档都能被唯一标识。MongoDB采用`ObjectId`，而不是其它比较常规的（如自动增加的主键）的主要原因，因为在多个服务器上同步自动增加的键值既费力又费时。因为涉及MongoDB的初衷就是用作分布式数据库，所以能够在分片环境中生成唯一的标识符非常重要。

`ObjectId`使用12字节的存储空间，是一个有24个十六进制数字组成的字符串。由于看起来很长，不少人会觉得难以理解，但关键是要知道这个长长的`ObjectId`是实际存储的两倍长。

`ObjectId`的12字节按照如下方式生成：

|0-3|4-6|7-8|9-11|
|---|---|---|----|
|时间戳|机器|PID|计数器|


`ObjectId`的前四个字节是从标准纪元开始的时间戳，单位为妙。使用时间戳会带来一些不错的属性。

- 时间戳，与后面的5个字节组合起来，提供了一个秒级别的唯一性。
- 由于时间戳在前，意味着`ObjectId`大致会按插入顺序排序。这对于某些方面很有用，比如将其最为索引提高效率，但是这是没有保证的，仅仅是”大致“。
- 这个4个字节隐含了文档的创建时间。绝大多数驱动程序都会提供一个方法，用于从`ObjectId`获取这些信息。

因为使用的是当前时间，很多用户担心要对服务器进行时钟同步。虽然在某些情况下，在服务器进行时间同步是个好主意，但是这其实没有必要，因为时间戳的实际值并不重要，只要它总是不停的增加就好了。


`ObjectId`随后的三个字节是主机的唯一标识符。通常是主机名的散列值(hash)。这样可以保证不同主机生成不同的`ObjectId`

为了保证同一机器上并发多进程产生的`ObjectId`是唯一的，接下来的两个字节来自产生`ObjectId`的进程标识符`PID`

前9个字节保证了同一秒不同机器不同进程产生的`ObjectId`是唯一的。最后3个字节是一个自动增加的计数器，确保相同进程同一秒产生的`ObjectId`也是不一样的。


```go
t := primitive.NewObjectID().Timestamp() //mongo-driver获取创建时间
```

## 索引

### 复合索引

### 唯一索引

### 稀疏索引

### 索引管理

## 范式化与反范式化

- 范式化 

范式化是将数据分散到多个不同集合，不同集合之间可以相互引用数据。
虽然很多文档可以引用某一块数据，但是这块数据只存储在一个集合中。
所以，如果要修改这块数据，只需要修改保存这块数据的那一个文档就行了。但是，MongoDB没有提供链接（join）工具，所以在不同集合之间执行连接查询需要进行多次查询。

- 反范式化

反范式化与范式化相反：将每个文档所需要的数据都嵌入在文档内部。
每个文档都拥有自己的数据副本，而不是所有文档共同引用同一个数据副本。
这意味着，如果信息发生了变化，那么所有相关文档都需要进行更新，但是在执行查询的时候，只需要一次查询，就可以得到所有数据。

- 何时采用范式化或反范式化？

决定何时采用范式化、反范式化是比较困难的。范式化能够提高数据写入速度，反范式化能够提高数据读取速度。
不过有几条经验可以供参考：

1. 信息更新更频繁还是读取更频繁？

 	一般来说，数据生成越频繁，就越不应该将这些数据内嵌到其他文档中。
 	如果这些数据会定期更新，那么范式化是最好的选择，如果数据变化不频繁，为了优化更新效率而牺牲读取效率就不值得了。例如教科书上介绍范式化的一个例子是将用户和用户地址保存在不同的集合中。但是任务几乎不会改变住址，所以不应该为了这种概率极低的情况而牺牲每一次查询的效率

2. ”多“的关系使用引用（范式）方式比较好，”少“的关系使用内嵌（反范式）的方式比较好
	
	一个集合中包含的对其他集合的引用数据叫做基数。例如博客应用程序。每一篇文章都有一个标题，每一个作者都有多个文章，每一篇文章都有多个标签和多个评论。确定他们之前”多“与”少“的关系，更有助于我们进行判断采用哪种方式

## 不适合使用MongoDB的场景

尽管MongoDB是一个通用数据库，可以用在大部分应用程序中，但它并非万能的。MongoDB不支持下面这些应用场景。

- MongoDB不支持事务，对于事务性有要求的应用程序不建议使用MongoDB。可以用几种方式实现简单的类事务语义，尤其是操作单个文档时，但是数据库并不能强制要求用户这么做。因此，你可以让所有客户端都遵循你设定的某种语义规范（比如执行前先检查锁），但是无法阻挡不知情的用户或者恶意用户把事情变成一团糟。

- 在多个不同维度上对不同类型的数据进行连接，这是关系型数据库擅长的事情。
MongoDB不支持这么做，以后也很可能不支持。

- 最后，如果你使用的工具不支持MongoDB，那可能你应该选择一个关系型数据库而不是MongoDB。有很多工具并不支持MongoDB，从SQLAPI chemy到 WordPress。支持MongoDB的工具越来越多，但是目前来说仍然不如关系型数据库多。


* 参考
    * [use-the-index-luke](https://use-the-index-luke.com/)