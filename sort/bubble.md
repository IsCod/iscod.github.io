# 冒泡排序

冒泡排序是大多数人接触的第一种排序算法，
简单容易，但是效率较低。
实际工作当中基本不使用，但却是我们开始学习排序算法最佳选择

## 算法介绍

1, 比较相邻两个元素，如果第一个比第二个大，就交换他们

2, 经过一轮迭代，最后一位数成为最大数

3, 继续 `1`步骤，但是只到倒数第二位

4, 继续`3`步骤直至结束

如下乱序数列：`[10,6,11,21,16]`
```
步骤1：
第一轮开始：
第一个数：[10,6,11,21,7] 10 > 6 交换 10和6
第二个数：[6,10,11,21,7] 10 < 11 不交换
第三个数：[6,10,11,21,7] 11 < 21 不交换
第四个数：[6,10,11,21,7] 21 > 7 交换
结束：[6,10,11,7,21]

步骤3：继续 1步骤
第二轮：开始：
第一个数：[6,10,11,7,21] 6 < 10 不交换
第二个数：[6,10,11,7,21] 10 < 11 不交换
第三个数：[6,10,11,7,21]  11 > 7 交换
结束：[6,10,7,11,21]

步骤3：继续 1步骤
第三轮：开始：
第一个数：[6,10,7,11,21] 6 < 10 不交换
第二个数：[6,10,7,11,21] 10 > 7 交换
结束：[6,7,10,11,21]

步骤3：继续 1步骤
第四轮：开始：
第一个数：[6,7,10,11,21] 6 < 7 不交换
结束：[6,7,10,11,21]

结果：[6,7,10,11,21]
```
## 复杂度

`O(n^2)`

## 代码实现

Golang: 
```go
package main

import "fmt"

func BubbleSort(s []int) []int {
    for i := 0; i < len(s); i++ {
        for j := 0; j < i; j++ {
            if s[i] < s[j] {
                s[i], s[j] = s[j], s[i]
            }
        }
    }
    return s
}

func main() {
    var slice = []int{10, 6, 11, 21, 7}
    fmt.Println(BubbleSort(slice))

}
```

输出： 
```[6 7 10 11 21]```

PHP

```php
function bubble_sort(array $arr): array
{
    for ($i = count($arr) - 1; $i > 0; $i--) {
        for ($j = 0; $j < $i; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
                $val = $arr[$j + 1];
                $arr[$j + 1] = $arr[$j];
                $arr[$j] = $val;
            }
        }
    }
    return $arr;
}

$arr = bubble_sort([10, 6, 11, 21, 7]);
print_r($arr);
```

输出： 
```
Array
(
    [0] => 6
    [1] => 7
    [2] => 10
    [3] => 11
    [4] => 21
)
```

* 参考
    * [数据结构和算法](https://www.bookstack.cn/read/hunterhug-goa.c/algorithm-sort-bubble_sort.md)
    * [经典排序算法](https://www.bookstack.cn/read/JS-Sorting-Algorithm/1.bubbleSort.md)
